# Contract Review of the RealmFacet.sol

- The contract is inheriting  the contract Modifiers from the library/AppStorage.sol.
- The AppStorage.sol has 12 unique constant variables, a struct Parcel, a atruct AppStorage that contains the stoage varaibles to store, the library LibAppStorage sets the appstorage in a slot. Contract Modiifier sets an onlyParcelOwner which can call a certain tokenId. The modifier onlyOwner ensures that it is the person that deployed the Diamond.

## State Variables

- A constant realm token supply of 420069
- A user defined Struct MintParcelInput that describes a parcel
- There are seven various events that the contract uses subgrapgh to emit.
  ```event ResyncParcel(uint256 _realmId);
  event EquipInstallation(uint256 _realmId, uint256 _installationId, uint256 _x, uint256 _y);
  event UnequipInstallation(uint256 _realmId, uint256 _installationId, uint256 _x, uint256 _y);
  event EquipTile(uint256 _realmId, uint256 _tileId, uint256 _x, uint256 _y);
  event UnequipTile(uint256 _realmId, uint256 _tileId, uint256 _x, uint256 _y);
  event AavegotchiDiamondUpdated(address _aavegotchiDiamond);
  event InstallationUpgraded(uint256 _realmId, uint256 _prevInstallationId, uint256 _nextInstallationId, uint256 _coordinateX, uint256 _coordinateY) ```


## Function Definitons

</br>
Function MaxSupply is an external function that returns the total realm token supply.
<br/><br/>

Function mintParcels mints an array of token IDs to an address using thr MintParcelInput struct that descibes a parcel. It also changes the struct Parcel from the AppStorage.sol and assigns it to the MintParcelInput struct.
It uses the imported LibERC721 function safemint to transfer a token with a unique Id to an address to.

Function equipInstallation is an external function that takes in five parameters and emits an event after the realmId has been equipped. Before a parcel is installed the library libSignature uses a function isvalid to check if the bytes32 hash generated is the right one. The hashe is generated by hashing together a bytes32 messageHash , a bytes signature and a  bytes pubkey.
The isValid uses a helper internal function getEthSignedMessageHash which takes in a messageHash and does a kecakk256, abi.encodedPacked of a string and the messageHash.

- Creates a memory pointer installation of the struct InstallationType InstallationDiamondInterface and assigns it to the InstallationDiamondInterface(s.InstallationDiamond which is an address).getInstallationType(_installationId) which returns a struct of the type InstructionType.
    <br/>

- Checks if the parcel has an installationType where 0 is an installationType of Altar. The realmId must have an installation of an altarId, if not an altarID must be equipped.
    <br />

- Checks if the installation Type is either of the type 1 or 2. The curent round which is a survey must be greater than 1, if not an installation must occur.
    <br/>

-  Checks that the installationType must be a gotchilodge. The requirment for the check is that the identiifer of the parcel should be of a datatype lodgeId which is assigned to the parcel being equipped.
    <br/>

- Uses the library LibRealm function placeInstallation which takes in four paramters, the _realmId which is the identifier of the parcel which the installation is being equipped,_installationId the identifier of the installation being equiped, _x and_y which are the starting coordinates of the installaion. <br/>PlaceInstallation checks if the coordinates are available onchain.
    The function equipInstallation is been called from InstallationDiamondInterface using the address of the InstallationDiamond. <br/> The equipInstallation takes in three parameters (msg.sender,_realmId,_installationId), and allows the user to equip an installation to a parcel.
    <br/>
    Uses the library LibAlcheica function increaseTraits(_realmId,_installationId)
    <br/><br/>

Function UnequipInstallation is an external function with two modifiers onlyParcelOwner(_realmId), gameActive takes in five paramneters,_realmId,_installationId,_x ,_y and signature

- Before a parcel unequipped the library libSignature uses a function isvalid to check if the bytes32 hash generated is the right one. The hash is generated by hashing together a bytes32 messageHash , a bytes signature and a  bytes pubkey.
    The isValid uses a helper internal function getEthSignedMessageHash which takes in a messageHash and does a kecakk256, abi.encodedPacked of a string and the messageHash.
    <br/>

- The InstallationDiamondInterface is instiated by creating a contract pointer installationDiamond. Which means installationDiamond has a data structure of type installationDiamondInterface.
    </br>
- A memory pointer installation of the data structure InstallationDiamondInterface.InstallationType is assigned to a contract that calls an external function getInstallationType(_installationId) that returns a data structure InstallationType.
    <br/>
- Checks if the installationType has a gotchilodge. If true unequip the gotchilodge from the parcel with that identiifer.
- Uses the library LibRealm function removeInstallation which takes in four paramters, the_realmId which is the identifier of the parcel which the installation is being equipped,_installationId the identifier of the installation being equiped,_x and_y which are the starting coordinates of the installaion. PlaceInstallation checks if the coordinates are available onchain.
    <br/>
- Does a for loop on alchemicaCost, which is a fixed array of length four, and instatiate an IERC20 of the token alchemica.
    <br/>
    For each of the alchemicaCost a refund alchemicaRefund is calculated. and the alchemicaRefund is transferred to the msg.sender.
    <br/>

- The function unequipInstallation is been called from InstallationDiamondInterface using the address of the InstallationDiamond. <br/>
    The unequipInstallation takes in three parameters (msg.sender,_realmId,_installationId), and allows the user to unequip an installation from a parcel.
    <br/>
    LibAlchemica.reduceTraits which takes in two paramters _realmId and_insttallation_id which unequip all harvesters, claim alchemica balance, unequip reservoir before the traits are removed from the_realmId.
    An event is emitted after_realmId has been unequipped.
    <br/><br/>

function equipTile is an external function with two modifiers onlyParcelOwner and gameActive which takes in five parameters, _realmId,_tileId, _x,_y and a signature.
<br/>

- The modifier onlyParcelOwner allows a parcel owner to equip a tile.
<br/>

- The _x and_y denote the starting coordinates of the tile and are used to make sure that slot is available on a parcel ,_realmId The identifier of the parcel which the tile is being equipped on , _tileId The identifier of the tile being equipped,_x The x(horizontal) coordinate of the tile, _y The y(vertical) coordinate of the tile.
<br/>

- Before a parcelowner equip a tile  the library libSignature uses a function isvalid to check if the bytes32 hash generated is the right one. The hash is generated by hashing together a bytes32 messageHash , a bytes signature and a  bytes pubkey.
    The isValid uses a helper internal function getEthSignedMessageHash which takes in a messageHash and does a kecakk256, abi.encodedPacked of a string and the messageHash. The messageHash is an ```abi.encodePacked(_reamlmId,_tileId, _x ,_y)```.

- Library LibRealm calls an internal placeTile function which takes four parameters, and checks if slots are available onchain, if it is avialbale then the tiles are placed.
    <br/>
    The function equipTile is been called from TileDiamondInterface using the address of the tileDiamond. The equipTile takes in three parameters, the msg.sender, _realmId,_tileId.
    <br/> An event is emitted after a _realmId has been equip with a tile.

function UnequipTile  is an external function with two modifiers onlyParcelOwner and gameActive which takes in five parameters, _realmId,_tileId, _x,_y and a signature.
<br/>

- The modifier onlyParcelOwner allows a parcel owner to equip a tile.
<br/>

- The _x and_y denote the starting coordinates of the tile and are used to make sure that slot is available on a parcel ,_realmId The identifier of the parcel which the tile is being equipped on , _tileId The identifier of the tile being equipped,_x The x(horizontal) coordinate of the tile, _y The y(vertical) coordinate of the tile.
<br/>

- Before a parcelowner unequip a tile  the library libSignature uses a function isvalid to check if the bytes32 hash generated is the right one. The hash is generated by hashing together a bytes32 messageHash , a bytes signature and a  bytes pubkey.
    The isValid uses a helper internal function getEthSignedMessageHash which takes in a messageHash and does a kecakk256, abi.encodedPacked of a string and the messageHash. The messageHash is an ```abi.encodePacked(_reamlmId,_tileId, _x ,_y)```.

- Library LibRealm calls an internal removeTile function which takes four parameters, and checks if slots are available onchain, if it is avialbale then the tiles are placed.
    <br/>
    The function unequipTile is been called from TileDiamondInterface using the address of the tileDiamond. The unequipTile takes in three parameters, the msg.sender, _realmId,_tileId.
    <br/> An event is emitted after a _realmId has been unequip with a tile.

- Creates a user defined struct called ParcelOutput that has variables of

    ```
    string parcelId;
    string parcelAddress;
    address owner;
    uint256 coordinateX; //x position on the map
    uint256 coordinateY; //y position on the map
    uint256 size; //0=humble, 1=reasonable, 2=spacious vertical, 3=spacious horizontal, 4=partner
    uint256 district;
    uint256[4] boost;
    uint256 timeRemainingToClaim;
    ```

<br/><br/>
function resyncParcel is an external function with an onlyOwner modiifer that takes in a dynamic array of _tokenIds and does a for loop of the_tokenIds length.
<br/>
Which returns an event emiited from subgraph when_tokenIds are added.
<br/><br/>
function setAavegotchiDiamond is an external function with an onlyOwner modifier that takes in a parameter which is ```address_diamondAddress```, and sets the diamond address for Bazzar.
<br/>
The requirement for before an address is set is that the address to be set must not be an address(0).
<br/>
An event is emitted after a change in_diamondaddress.
<br/><br/>
function setGameActive is an external function with a modifier of onlyOwner which takes in a parameter ```bool_gameActive``` that checks if the game is still active.
<br/><br/>
function getParcelInfo is an external views function, which means it doesn't change state and returns a datastructure of ParcelOutput which is a user defined struct.It takes in a parameter of ```uint256_realmId```

- line 240 - 249:
  <br/>
    ```Parcel storage parcel = s.parcels[_realmId];```  Creates a storage pointer parcel.

    ```
    output_.parcelId = parcel.parcelId;
    output_.owner = parcel.owner;
    output_.coordinateX = parcel.coordinateX;
    output_.coordinateY = parcel.coordinateY;
    output_.size = parcel.size;
    output_.parcelAddress = parcel.parcelAddress;
    output_.district = parcel.district;
    output_.boost = parcel.alchemicaBoost;
    output_.timeRemainingToClaim = s.lastClaimedAlchemica[_realmId];
    ```

    reads the value from the memory pointer output to the storage pointer parcel.
<br/></br>

function checkCoordinates is public view function that takes in four parameters ```uint256 _realmId,
    uint256 _coordinateX,
    uint256 _coordinateY,
    uint256 _installationId```
<br/>

- To checkCoordinates require that buildGrid which is fixed array of [64] [64],where each square bracket represent coordinate x and coordinate y must be equal to installationId, the identiifer of the installation being checked.
<br/></br>

function upgradeInstallation is an external function with an onlyInstallationDiamond modifier which means it can only Installation diamond can call and has five parameters. ```
    uint256 _realmId,
    uint256 _prevInstallationId,
    uint256 _nextInstallationId,
    uint256 _coordinateX,
    uint256 _coordinateY```
    <br/>

- Before a_realmId installation are upgraded it has to remove installation, placeInstllation, reduceTraits and increaseTraits.
- ```LibRealm.removeInstallation(_realmId,_prevInstallationId, _coordinateX,_coordinateY);```. Uses the removeInstallation function from the library LibRealm which removes the installation from a _realmId.

- ```LibRealm.placeInstallation(_realmId,_nextInstallationId, _coordinateX,_coordinateY);```  uses the placeInstallation function from the library LibRealm to place installation to a _realmId.
- ```LibAlchemica.reduceTraits(_realmId,_prevInstallationId);``` uses the reduceTriats function from the library LibAlchemica to reduce the traits on the _realmIds by unequip all harvesters, claim alchemica balance unequip reservoir.
- ```LibAlchemica.increaseTraits(_realmId,_nextInstallationId)```;uses the increaseTraits function from the librarry LibAlchemica to increase traits on the _realmId.
- After an upgradeInstallation an event is emitted.
  
function addUpgradeQueueLength is an external function that has an onlyInstalledDiamond modifier that increases the QueueLength of _realmId.

function subUpgradeQueueLength is an external function that has an onlyInstalledDiamond modifier that decreases the QueueLength of _realmId.

function getParcelCapacity takes in two parameters ```uint256 _realmId, uint256_alchemicaType```. calculates the totalCapacity of the_realmId.

function getHumbleGrid takes in two parameters ```uint256 _parcelId, uint256_gridType```and returns an array uint256[8][8]

- if the size of the_parcelId == 0 where 0 represents a humble RealmFacet.

- A for loop of the length of the fixed arrays and a check that_gridType == 0 returns an output of ```output_[i][j] = s.parcels[_parcelId].buildGrid[i][j]```

- _gridType == 1 return an output of ```output_[i][j] = s.parcels[_parcelId].tileGrid[i][j]```

function getReasonableGrid takes in two parameters ```uint256 _parcelId, uint256_gridType```and returns an array uint256[16][16]

- if the size of the_parcelId == 1 where 1 represents a resonanble  RealmFacet.

- A for loop of the length of the fixed arrays and a check that_gridType == 0 returns an output of ```output_[i][j] = s.parcels[_parcelId].buildGrid[i][j]```

- _gridType == 1 return an output of ```output_[i][j] = s.parcels[_parcelId].tileGrid[i][j]```
  
function getSpaciousVerticalGrid takes in two parameters ```uint256 _parcelId, uint256_gridType```and returns an array uint256[32][64]

- if the size of the_parcelId == 2 where 2 represents a spacious vertical  RealmFacet.

- A for loop of the length of the fixed arrays[32][64] and a check that_gridType == 0 returns an output of ```output_[i][j] = s.parcels[_parcelId].buildGrid[i][j]```

- _gridType == 1 return an output of ```output_[i][j] = s.parcels[_parcelId].tileGrid[i][j]```

function getSpaciousHorizontalGrid takes in two parameters ```uint256 _parcelId, uint256_gridType```and returns an array uint256[64][32]

- require the size of the_parcelId == 3 where 3 represents a spacious horizontal RealmFacet.

- A for loop of the length of the fixed arrays[64][32] and a check that_gridType == 0 returns an output of ```output_[i][j] = s.parcels[_parcelId].buildGrid[i][j]```

- _gridType == 1 return an output of ```output_[i][j] = s.parcels[_parcelId].tileGrid[i][j]```

function getPaartnerGrid takes in two parameters ```uint256 _parcelId, uint256_gridType```and returns an array uint256[64][64]

- require the size of the_parcelId == 4 where 4 represents a paartner RealmFacet.

- A for loop of the length of the fixed arrays[64][64] and a check that_gridType == 0 returns an output of ```output_[i][j] = s.parcels[_parcelId].buildGrid[i][j]```

- _gridType == 1 return an output of ```output_[i][j] = s.parcels[_parcelId].tileGrid[i][j]```

function getParcelUpgradeQueueLength takes in a parameter ```uint256 _priceId``` and returns an upgradeQueueLength for a parcel.

function getParcelUpgradeQueueCapacity takes in a parameter ```uint256 _priceId``` and returns an upgradeQueueCapacity for a parcel.
